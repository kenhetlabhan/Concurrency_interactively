<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://www.downloadclipart.net/large/40245-number-28-clipart.png" type="image/png">
    <link rel="stylesheet" href="semaphores.css">
    <title>Concurrency Interactively</title>
    <div id="toptopwrap">
        <tittle>Concurrency Interactively: Semaphores</tittle>
    </div>
</head>
<nav>
    <div class="navbar">
        <a href="index.html">Home</a>
         <a href="quiz.html">Quiz</a>
        <div class="dropdown">
            <button class="dropbtn">Summary</button>
                <div class="dropdown-content">
                <a href="lock_based.html">Lock Based Concurrency</a>
                <a href="event_based.html">Event Based Concurrency</a>
                <a href="conditional_variables.html">Conditional Variables</a>
                <a href="locks.html">Locks</a>
                <a href="problems.html">Problems</a>
                <a href="semaphores.html">Semaphores</a>
        </div>
    </div>
</nav>
<body>
    <div id="centerwrap">
        <div class="container">
            <h1>About Semaphores:</h1>
            <p>
                Semaphores are variables which can be decremented by 1 and incremented by 1 with sem_wait() and sem_post() respectively. A semaphore can be used as a lock. It then prevents too many threads from accessing something at the same time. Each time a thread wants to access a piece of content that is protected by a semaphore it has to first decrement the semaphore value with sem_wait() before it can proceed. When the resulting value is negative, meaning the maximum number of threads that are allowed to enter that piece of content is already accessing the content, the thread canâ€™t continue and has to wait so it goes to sleep to preserve resources. When one of the threads that was accessing the content is done it increments the semaphore value by 1 and wakes up the waiting thread by calling sem_post() so it can now enter the content.

                You can also have a semaphore as a condition variable. A thread then has to wait for a condition to become true before it can continue doing its work. The semaphore is initially set to zero. If a thread has to wait for a condition to be met the thread will first call sem_wait() which decrements the semaphore value of 0 by 1 making it -1. When another thread then finishes its job which results in the condition being met it calls sem_post() which increments the semaphore value with 1 making it 0 again and wakes up one or more waiting threads so they can continue doing their work.
            </p>
        </div>
        <iframe src="https://trinket.io/embed/python3/00987eeaac?toggleCode=true" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
    </div>
</body>
</html>
