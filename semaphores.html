<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://www.downloadclipart.net/large/40245-number-28-clipart.png" type="image/png">
    <link rel="stylesheet" href="semaphores.css">
    <title>Concurrency Interactively</title>
    <div id="toptopwrap">
        <tittle>Concurrency Interactively: Semaphores</tittle>
    </div>
</head>
<nav>
    <div class="navbar">
        <a href="index.html">Home</a>
         <a href="quiz.html">Quiz</a>
        <div class="dropdown">
            <button class="dropbtn">Summary</button>
                <div class="dropdown-content">
                <a href="lock_based.html">Lock Based Concurrency</a>
                <a href="event_based.html">Event Based Concurrency</a>
                <a href="conditional_variables.html">Conditional Variables</a>
                <a href="locks.html">Locks</a>
                <a href="problems.html">Problems</a>
                <a href="semaphores.html">Semaphores</a>
        </div>
    </div>
</nav>
<body>
    
        <div class="container">
            <h1>About Semaphores:</h1>
            <p>
                Semaphores are parameters and can be used to create locks and conditional variables to manage concurrent programs. Semaphores have an integer value that can be changed with 2 functions.
            </p>
            <p> 
                sem_wait() is called by the waiting stand and decrements Semaphore’s value by 1.
                sem_post() is called by the running stand and increments Semaphore’s value by 1.
            </p>
            <p>
                The objective of a Semaphore is to prevent too many threads from accessing something at the same time. Each time a thread wants to access a piece of content that is protected by a semaphore it has to first call sem_wait().
                The tread can only proceed with the program and access the content if the semaphore value produced by decrementing is not negative.
                If the resulting value is negative, this means the maximum number of threads that are allowed to enter that piece of content are accessing the content at that time.Therefore, the thread can’t continue and has to wait so it goes to sleep to preserve resources. When one of the running threads that was accessing the content is done it increments the semaphore value by 1 and wakes up the waiting thread by calling sem_post() so it can now enter the content.
            </p>
            <p>
                You can also have a semaphore that acts as a condition variable. A thread then has to wait for a condition to become true before it can continue doing its work. The semaphore value is initially set to zero. If a thread has to wait for a condition to be met the thread will first call sem_wait() which decrements the semaphore value from 0 to -1. When another thread then finishes its job which results in the condition being met it calls sem_post() which increments the semaphore value from - 1 to 0 and wakes up one or more waiting threads so they can continue doing their work.
            </p>
            <p>
                The main difference between binary Semaphores that act as locks and semaphores that act as conditional variables is that binary Semaphores have an initialized value of 1 or the maximum number of threads that are allowed to access the content simultaneously.
            </p>
     <div id="centerwrap">
        </div>
        
        <iframe width="420" height="315"
         src="semaphore.mp4">
        
        <iframe src="https://www.online-python.com/kwgnCuEraU" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
    </div>
</body>
</html>
